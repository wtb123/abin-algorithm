## 一、Go自定义比较算法
```go
package main

import (
	"fmt"
	"sort"
)

type MyDefSlice struct {
	Id   int
	Name string
}

type MySlice []MyDefSlice

func (p MySlice) Less(i, j int) bool {
	return p[i].Id > p[j].Id
}

func (p MySlice) Len() int {
	return len(p)
}

func (p MySlice) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

func main() {
	mySlice := make(MySlice, 0)
	for i := 0; i < 10; i++ {
		mySlice = append(mySlice, MyDefSlice{
			Id:   i,
			Name: fmt.Sprintf("slice_%d", i),
		})
	}
	sort.Sort(mySlice)
	fmt.Printf("mySlice:%v\n", mySlice)
}

```

## 二、联合索引
1. 最左匹配原则：第一个字段是全局有序，其他的是全局无序的
![img.png](img.png)
2. 存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况：这种特殊情况就发生在范围查询

## 三、索引失效
1. 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；
2. 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
3. 最左匹配不符合
4. 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效

## 四、数据库的ACID
1. 持久性用到了 redo log （binlog好像是用来备份的？）
2. 原子性通过 undo log 来保证的
3. 数据的隔离性是用到了MVCC+锁（可重复读用到了间隙所，串行化用到了读写锁）
4. 一致性通过 持久性 + 原子性 + 隔离性保证的

## 五、缓存雪崩、缓存击穿、缓存穿透
1. 缓存雪崩：大量缓存数据在同一时间失效或者 Redis 故障宕机 \
情景1：大量数据同时过期 \
. 均匀设置过期时间 \
. 互斥锁（比如Go 的singleFlight）\
情景2：Redis宕机 \
. 服务熔断 \
. 请求限流
2. 缓存击穿
. 互斥锁（比如Go 的singleFight） \
. 不设置过期时间，由后台更新缓存 \
3. 缓存穿透 \
. 非法请求限制 \
. 缓存空值或者默认值（常用）
. 布隆过滤器快速判断数据是否存在

## 六、缓存不一致性
1. 讨论缓存不一致性最终的着眼点是：所有并发操作结束之后，Redis和Mysql里面的数据是否保持一致，其他的中间过程短暂不一致其实是没办法避免的，这个也不是主要着眼点：\
比如先更新数据库，再更新缓存，如果数据库已经更新好了，还没更新Redis，这时候读请求从Redis里面把数据读走了，算不算不一致？ \
答案是：不算。因为对用户感知来说，只有Redis更新成功之后才会返回给他成功的结果。此后的查询都是一致的，并没有显示修改了但是查询旧值的问题。
2. 所以对这类题目的系统性思考是这样子的：\
21 一般不采用双更新的方法，因为更新操作相对删除更复杂，而且数据一更新就update缓存，容易把过多冷数据放到缓存里面 \
22 最常用的就是方法就是先更新db，再删除缓存（配合设置过期时间）能满足大部分需求，这种情况仍然会面临的问题就是小概率的不一致和删除缓存失败 \
   解决方案就是使用 Kafka 进行订阅重试或者订阅mysql的binlog（这个暂时不是很理解）
23 补充，针对先删除redis再更新db也会存在不一致问题，可以采用延迟双删的方法，但是不好控制延迟的时间。仔细思考会发现对比之下，不就是先更新db再删除redis加了个延迟吗，效果不是一样的吗？（是否我理解有什么误区？）所以延迟双删也不如 \
   22的方法更好
